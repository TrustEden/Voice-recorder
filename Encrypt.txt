
Text icon
Encrypt.txt

Page
1
/
1
100%
ï»¿"""
Eden Encryption Plugin - FIXED VERSION
Real-time audio encryption with consent binding and multi-stream output.


File: src/plugins/encryption/plugin.py
"""


import os
import time
import json
import logging
import threading
import queue
import struct
import wave
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field
from pathlib import Path
from collections import defaultdict, deque


import numpy as np


# FIXED: Proper imports from the existing encryption module
from src.utils.encryption_module import (
    generate_aes_key,
    AESGCM,
    ConsentBoundEncryption as BaseConsentBoundEncryption,
    encrypt_aes_gcm,
    decrypt_aes_gcm
)


# FIXED: Proper imports from other Eden components
from src.plugins.consent.manager import ConsentManager
from src.core.audio_recorder import AudioChunk, PluginInterface




@dataclass
class EncryptionConfig:
    """Configuration for encryption plugin"""
    enabled: bool = True
    output_directory: str = "data/sessions"
    master_key_path: str = "data/keys/master.key"
    real_time_encryption: bool = True
    chunk_encryption_threshold: float = 1.0  # seconds
    separate_speaker_files: bool = True
    gpu_acceleration: bool = True
    encryption_algorithm: str = "AES-256-GCM"
    file_format: str = "wav"
    
    # Security settings
    secure_memory: bool = True
    immediate_key_disposal: bool = True
    consent_binding: bool = True




@dataclass
class SessionMetadata:
    """Metadata for an encryption session"""
    session_id: str
    start_time: float
    end_time: Optional[float] = None
    speakers: Dict[str, dict] = field(default_factory=dict)
    consent_tokens: Dict[str, str] = field(default_factory=dict)
    encryption_info: Dict[str, Any] = field(default_factory=dict)
    file_manifest: Dict[str, str] = field(default_factory=dict)
    
    def to_dict(self) -> dict:
        return {
            'session_id': self.session_id,
            'start_time': self.start_time,
            'end_time': self.end_time,
            'speakers': self.speakers,
            'consent_tokens': self.consent_tokens,
            'encryption_info': self.encryption_info,
            'file_manifest': self.file_manifest
        }




class AudioStreamBuffer:
    """Secure buffer for audio streams with real-time encryption"""
    
    def __init__(self, stream_id: str, sample_rate: int, encryption_threshold: float):
        self.stream_id = stream_id
        self.sample_rate = sample_rate
        self.encryption_threshold = encryption_threshold
        
        # Audio data buffer
        self.audio_chunks: deque = deque()
        self.total_samples = 0
        self.buffer_start_time = None
        
        # Thread safety
        self.lock = threading.Lock()
        
        # Encryption tracking
        self.encrypted_chunks = []
        self.last_encryption_time = 0
        
        self.logger = logging.getLogger(__name__)
    
    def add_chunk(self, chunk: AudioChunk) -> bool:
        """
        Add audio chunk to buffer
        Returns True if buffer should be encrypted
        """
        with self.lock:
            if self.buffer_start_time is None:
                self.buffer_start_time = chunk.timestamp
            
            self.audio_chunks.append(chunk)
            self.total_samples += len(chunk.data)
            
            # Check if we should encrypt
            buffer_duration = chunk.timestamp - self.buffer_start_time
            should_encrypt = buffer_duration >= self.encryption_threshold
            
            return should_encrypt
    
    def get_buffer_audio(self) -> tuple[np.ndarray, List[AudioChunk]]:
        """Get current buffer as continuous audio array"""
        with self.lock:
            if not self.audio_chunks:
                return np.array([]), []
            
            # Concatenate all audio chunks
            audio_data = np.concatenate([chunk.data for chunk in self.audio_chunks])
            chunks_info = list(self.audio_chunks)
            
            return audio_data, chunks_info
    
    def clear_buffer(self):
        """Clear the buffer after encryption"""
        with self.lock:
            self.audio_chunks.clear()
            self.total_samples = 0
            self.buffer_start_time = None
    
    def get_total_duration(self) -> float:
        """Get total duration of buffered audio"""
        return self.total_samples / self.sample_rate if self.total_samples > 0 else 0.0




class ConsentAwareEncryption(BaseConsentBoundEncryption):
    """FIXED: Extended consent-aware encryption using the base implementation"""
    
    def __init__(self, master_key_path: str, consent_manager: ConsentManager = None):
        self.master_key_path = master_key_path
        self.consent_manager = consent_manager
        self.session_keys: Dict[str, bytes] = {}
        
        # Load or create master key
        self.master_key = self._load_or_create_master_key()
        
        # Initialize base class with master key
        super().__init__(self.master_key)
        
        self.logger = logging.getLogger(__name__)
    
    def _load_or_create_master_key(self) -> bytes:
        """Load existing master key or create new one"""
        try:
            if os.path.exists(self.master_key_path):
                with open(self.master_key_path, 'rb') as f:
                    master_key = f.read()
                self.logger.info("Loaded existing master key")
                return master_key
            else:
                # FIXED: Use proper import from encryption module
                master_key = generate_aes_key(32)  # AES-256
                
                # Save master key
                os.makedirs(os.path.dirname(self.master_key_path), exist_ok=True)
                with open(self.master_key_path, 'wb') as f:
                    f.write(master_key)
                
                self.logger.info("Created new master key")
                return master_key
                
        except Exception as e:
            self.logger.error(f"Error with master key: {e}")
            # Fallback to generated key (not persistent)
            return generate_aes_key(32)
    
    def get_session_key(self, session_id: str) -> bytes:
        """Get or create session key for encryption session"""
        if session_id not in self.session_keys:
            # FIXED: Use proper function from encryption module
            self.session_keys[session_id] = generate_aes_key(32)
            self.logger.info(f"Generated new session key for {session_id}")
        
        return self.session_keys[session_id]
    
    def encrypt_audio_with_consent(self, audio_data: np.ndarray, 
                                  consent_token: str, 
                                  session_id: str,
                                  metadata: dict = None) -> bytes:
        """
        Encrypt audio data with consent token binding
        """
        try:
            # Check consent status if manager available
            if self.consent_manager and not self.consent_manager.is_consent_active(consent_token):
                raise ValueError(f"Consent token {consent_token} is not active")
            
            # Convert audio to bytes
            audio_bytes = (audio_data * 32767).astype(np.int16).tobytes()
            
            # Create encryption payload with metadata
            payload = {
                'audio_data': audio_bytes,
                'consent_token': consent_token,
                'session_id': session_id,
                'timestamp': time.time(),
                'metadata': metadata or {}
            }
            
            payload_bytes = json.dumps(payload, default=str).encode() + b'\x00' + audio_bytes
            
            # Get session key
            session_key = self.get_session_key(session_id)
            
            # FIXED: Use proper encryption function from utils
            # Use consent token as AAD (Additional Authenticated Data)
            encrypted_data = encrypt_aes_gcm(payload_bytes, session_key, consent_token.encode())
            
            return encrypted_data
            
        except Exception as e:
            self.logger.error(f"Encryption failed: {e}")
            raise
    
    def decrypt_audio_with_consent(self, encrypted_data: bytes, 
                                  consent_token: str, 
                                  session_id: str) -> tuple[np.ndarray, dict]:
        """
        Decrypt audio data with consent token validation
        """
        try:
            # Check consent status if manager available
            if self.consent_manager and not self.consent_manager.is_consent_active(consent_token):
                raise ValueError(f"Consent token {consent_token} is not active")
            
            # Get session key
            session_key = self.get_session_key(session_id)
            
            # FIXED: Use proper decryption function from utils
            # Decrypt with consent token validation
            decrypted_payload = decrypt_aes_gcm(encrypted_data, session_key, consent_token.encode())
            
            # Parse payload
            separator_idx = decrypted_payload.find(b'\x00')
            metadata_bytes = decrypted_payload[:separator_idx]
            audio_bytes = decrypted_payload[separator_idx + 1:]
            
            # Parse metadata
            payload_info = json.loads(metadata_bytes.decode())
            
            # Convert audio back to numpy array
            audio_data = np.frombuffer(audio_bytes, dtype=np.int16).astype(np.float32) / 32767.0
            
            return audio_data, payload_info['metadata']
            
        except Exception as e:
            self.logger.error(f"Decryption failed: {e}")
            raise
    
    def cleanup_session(self, session_id: str):
        """Securely dispose of session key"""
        if session_id in self.session_keys:
            # Overwrite key memory with zeros (basic secure disposal)
            key = self.session_keys[session_id]
            # Create new bytearray of zeros to overwrite
            zero_array = bytearray(len(key))
            # Clear the reference
            del self.session_keys[session_id]
            self.logger.info(f"Disposed session key for {session_id}")




class EncryptionPlugin:
    """Main encryption plugin implementing PluginInterface"""
    
    def __init__(self, config: EncryptionConfig, consent_manager: ConsentManager = None):
        self.config = config
        self.consent_manager = consent_manager
        self._enabled = config.enabled
        
        # Encryption system
        self.encryption = ConsentAwareEncryption(config.master_key_path, consent_manager)
        
        # Session management
        self.current_session: Optional[SessionMetadata] = None
        self.session_directory: Optional[Path] = None
        
        # Audio stream buffers
        self.stream_buffers: Dict[str, AudioStreamBuffer] = {}
        self.full_conversation_buffer: AudioStreamBuffer = None
        
        # Output files
        self.output_files: Dict[str, Any] = {}
        
        # Threading
        self.encryption_queue = queue.Queue()
        self.encryption_thread = None
        self.running = threading.Event()
        
        self.logger = logging.getLogger(__name__)
    
    @property
    def name(self) -> str:
        return "EncryptionPlugin"
    
    @property
    def enabled(self) -> bool:
        return self._enabled
    
    def process_audio(self, chunk: AudioChunk) -> Optional[AudioChunk]:
        """Process audio chunk for encryption (transparent to other plugins)"""
        if not self.enabled or not self.current_session:
            return chunk
        
        try:
            # Add to full conversation buffer
            if self.full_conversation_buffer:
                should_encrypt_full = self.full_conversation_buffer.add_chunk(chunk)
                if should_encrypt_full:
                    self._queue_encryption("full_conversation", chunk.consent_token)
            
            # Add to speaker-specific buffer if available
            if chunk.speaker_id and chunk.speaker_id in self.stream_buffers:
                should_encrypt_speaker = self.stream_buffers[chunk.speaker_id].add_chunk(chunk)
                if should_encrypt_speaker:
                    self._queue_encryption(chunk.speaker_id, chunk.consent_token)
            elif chunk.speaker_id and chunk.speaker_id not in self.stream_buffers:
                # Create new speaker buffer
                self._create_speaker_buffer(chunk.speaker_id, chunk.sample_rate)
                self.stream_buffers[chunk.speaker_id].add_chunk(chunk)
        
        except Exception as e:
            self.logger.error(f"Error processing audio chunk: {e}")
        
        # Return original chunk unchanged (transparent operation)
        return chunk
    
    def on_recording_started(self, session_id: str) -> None:
        """Initialize encryption session"""
        try:
            self.logger.info(f"Starting encryption session: {session_id}")
            
            # Create session metadata
            self.current_session = SessionMetadata(
                session_id=session_id,
                start_time=time.time()
            )
            
            # Create session directory
            session_dir_name = f"session_{int(time.time())}_{session_id.split('_')[-1]}"
            self.session_directory = Path(self.config.output_directory) / session_dir_name
            self.session_directory.mkdir(parents=True, exist_ok=True)
            
            # Initialize full conversation buffer
            self.full_conversation_buffer = AudioStreamBuffer(
                "full_conversation", 
                16000,  # Default sample rate
                self.config.chunk_encryption_threshold
            )
            
            # Start encryption worker thread
            self.running.set()
            self.encryption_thread = threading.Thread(
                target=self._encryption_worker,
                daemon=True,
                name="EncryptionWorker"
            )
            self.encryption_thread.start()
            
        except Exception as e:
            self.logger.error(f"Failed to start encryption session: {e}")
    
    def on_recording_stopped(self, session_id: str) -> None:
        """Finalize encryption session"""
        try:
            self.logger.info(f"Stopping encryption session: {session_id}")
            
            if self.current_session:
                self.current_session.end_time = time.time()
                
                # Final encryption of all remaining buffers
                self._encrypt_all_remaining_buffers()
                
                # Save session metadata
                self._save_session_metadata()
                
                # Close all output files
                self._close_output_files()
                
                # Cleanup session key
                self.encryption.cleanup_session(session_id)
            
            # Stop encryption thread
            self.running.clear()
            if self.encryption_thread and self.encryption_thread.is_alive():
                self.encryption_thread.join(timeout=2.0)
            
            # Reset session state
            self._reset_session_state()
            
        except Exception as e:
            self.logger.error(f"Failed to stop encryption session: {e}")
    
    def on_speaker_detected(self, speaker_id: str, session_id: str) -> None:
        """Handle new speaker detection"""
        if not self.enabled or not self.current_session:
            return
        
        try:
            # Add speaker to session metadata
            self.current_session.speakers[speaker_id] = {
                'first_detected': time.time(),
                'total_chunks': 0,
                'total_duration': 0.0
            }
            
            self.logger.info(f"New speaker detected for encryption: {speaker_id}")
            
        except Exception as e:
            self.logger.error(f"Error handling speaker detection: {e}")
    
    def _create_speaker_buffer(self, speaker_id: str, sample_rate: int):
        """Create new audio buffer for speaker"""
        self.stream_buffers[speaker_id] = AudioStreamBuffer(
            speaker_id,
            sample_rate,
            self.config.chunk_encryption_threshold
        )
        
        # Update session metadata
        if self.current_session and speaker_id not in self.current_session.speakers:
            self.current_session.speakers[speaker_id] = {
                'first_detected': time.time(),
                'total_chunks': 0,
                'total_duration': 0.0
            }
    
    def _queue_encryption(self, stream_id: str, consent_token: str):
        """Queue encryption task for background processing"""
        try:
            self.encryption_queue.put({
                'stream_id': stream_id,
                'consent_token': consent_token,
                'timestamp': time.time()
            }, block=False)
        except queue.Full:
            self.logger.warning(f"Encryption queue full, dropping task for {stream_id}")
    
    def _encryption_worker(self):
        """Background worker thread for encryption tasks"""
        while self.running.is_set():
            try:
                # Get encryption task
                try:
                    task = self.encryption_queue.get(timeout=1.0)
                except queue.Empty:
                    continue
                
                # Process encryption task
                self._process_encryption_task(task)
                self.encryption_queue.task_done()
                
            except Exception as e:
                self.logger.error(f"Encryption worker error: {e}")
                time.sleep(0.1)
    
    def _process_encryption_task(self, task: dict):
        """Process individual encryption task"""
        stream_id = task['stream_id']
        consent_token = task['consent_token']
        
        try:
            # Get appropriate buffer
            if stream_id == "full_conversation":
                buffer = self.full_conversation_buffer
            elif stream_id in self.stream_buffers:
                buffer = self.stream_buffers[stream_id]
            else:
                self.logger.warning(f"Unknown stream ID for encryption: {stream_id}")
                return
            
            # Get buffer audio
            audio_data, chunks_info = buffer.get_buffer_audio()
            
            if len(audio_data) == 0:
                return
            
            # Create metadata for encryption
            metadata = {
                'stream_id': stream_id,
                'chunk_count': len(chunks_info),
                'duration': buffer.get_total_duration(),
                'sample_rate': buffer.sample_rate
            }
            
            # Encrypt audio data
            encrypted_data = self.encryption.encrypt_audio_with_consent(
                audio_data,
                consent_token,
                self.current_session.session_id,
                metadata
            )
            
            # Save encrypted data
            self._save_encrypted_chunk(stream_id, encrypted_data, audio_data, metadata)
            
            # Clear buffer
            buffer.clear_buffer()
            
            # Update session statistics
            if self.current_session and stream_id in self.current_session.speakers:
                speaker_stats = self.current_session.speakers[stream_id]
                speaker_stats['total_chunks'] += len(chunks_info)
                speaker_stats['total_duration'] += metadata['duration']
            
        except Exception as e:
            self.logger.error(f"Failed to process encryption task for {stream_id}: {e}")
    
    def _save_encrypted_chunk(self, stream_id: str, encrypted_data: bytes, 
                            audio_data: np.ndarray, metadata: dict):
        """Save encrypted chunk and corresponding raw audio"""
        try:
            # File paths
            raw_filename = f"{stream_id}_clean.wav"
            encrypted_filename = f"{stream_id}_encrypted.enc"
            
            raw_path = self.session_directory / raw_filename
            encrypted_path = self.session_directory / encrypted_filename
            
            # Save raw audio (append mode for streaming)
            self._append_to_wav_file(raw_path, audio_data, metadata['sample_rate'])
            
            # Save encrypted data (append mode)
            with open(encrypted_path, 'ab') as f:
                # Write chunk header (size + metadata)
                chunk_header = struct.pack('I', len(encrypted_data))
                f.write(chunk_header + encrypted_data)
            
            # Update file manifest
            if self.current_session:
                self.current_session.file_manifest[stream_id + '_raw'] = str(raw_path)
                self.current_session.file_manifest[stream_id + '_encrypted'] = str(encrypted_path)
            
            self.logger.debug(f"Saved encrypted chunk for {stream_id}: {len(encrypted_data)} bytes")
            
        except Exception as e:
            self.logger.error(f"Failed to save encrypted chunk for {stream_id}: {e}")
    
    def _append_to_wav_file(self, file_path: Path, audio_data: np.ndarray, sample_rate: int):
        """Append audio data to WAV file"""
        # Convert to 16-bit PCM
        audio_int16 = (audio_data * 32767).astype(np.int16)
        
        if file_path.exists():
            # Append to existing file
            with wave.open(str(file_path), 'r+b') as wav_file:
                # Seek to end and append
                wav_file.setpos(wav_file.getnframes())
                wav_file.writeframes(audio_int16.tobytes())
        else:
            # Create new file
            with wave.open(str(file_path), 'wb') as wav_file:
                wav_file.setnchannels(1)  # Mono
                wav_file.setsampwidth(2)  # 16-bit
                wav_file.setframerate(sample_rate)
                wav_file.writeframes(audio_int16.tobytes())
    
    def _encrypt_all_remaining_buffers(self):
        """Encrypt any remaining audio in buffers"""
        try:
            # Encrypt full conversation buffer
            if self.full_conversation_buffer:
                audio_data, chunks_info = self.full_conversation_buffer.get_buffer_audio()
                if len(audio_data) > 0:
                    # Use first chunk's consent token (or default)
                    consent_token = chunks_info[0].consent_token if chunks_info else "session_end"
                    self._queue_encryption("full_conversation", consent_token)
            
            # Encrypt all speaker buffers
            for speaker_id, buffer in self.stream_buffers.items():
                audio_data, chunks_info = buffer.get_buffer_audio()
                if len(audio_data) > 0:
                    consent_token = chunks_info[0].consent_token if chunks_info else "session_end"
                    self._queue_encryption(speaker_id, consent_token)
            
            # Wait for encryption queue to empty
            self.encryption_queue.join()
            
        except Exception as e:
            self.logger.error(f"Error encrypting remaining buffers: {e}")
    
    def _save_session_metadata(self):
        """Save session metadata to JSON file"""
        try:
            if not self.current_session or not self.session_directory:
                return
            
            metadata_path = self.session_directory / "metadata.json"
            
            with open(metadata_path, 'w') as f:
                json.dump(self.current_session.to_dict(), f, indent=2)
            
            self.logger.info(f"Saved session metadata to {metadata_path}")
            
        except Exception as e:
            self.logger.error(f"Failed to save session metadata: {e}")
    
    def _close_output_files(self):
        """Close any open output file handles"""
        for file_handle in self.output_files.values():
            try:
                if hasattr(file_handle, 'close'):
                    file_handle.close()
            except Exception as e:
                self.logger.warning(f"Error closing file handle: {e}")
        
        self.output_files.clear()
    
    def _reset_session_state(self):
        """Reset all session state"""
        self.current_session = None
        self.session_directory = None
        self.stream_buffers.clear()
        self.full_conversation_buffer = None
        self.output_files.clear()
    
    def cleanup(self) -> None:
        """Clean up plugin resources"""
        self.running.clear()
        
        if self.encryption_thread and self.encryption_thread.is_alive():
            self.encryption_thread.join(timeout=2.0)
        
        self._close_output_files()
        
        # Cleanup any remaining session keys
        if self.current_session:
            self.encryption.cleanup_session(self.current_session.session_id)
        
        self.logger.info("Encryption plugin cleaned up")




# Factory function
def create_encryption_plugin(config_path: str = "config/plugins_config.yaml",
                           consent_manager: ConsentManager = None) -> EncryptionPlugin:
    """Create encryption plugin with configuration"""
    try:
        import yaml
        with open(config_path, 'r') as f:
            config_dict = yaml.safe_load(f)
        
        encryption_dict = config_dict.get('plugins', {}).get('encryption', {})
        config = EncryptionConfig(**encryption_dict)
        
        return EncryptionPlugin(config, consent_manager)
        
    except Exception as e:
        logging.warning(f"Error loading encryption config: {e}, using defaults")
        return EncryptionPlugin(EncryptionConfig(), consent_manager)




if __name__ == "__main__":
    # Test the encryption plugin
    logging.basicConfig(level=logging.INFO)
    
    # Create test plugin
    plugin = create_encryption_plugin()
    
    print(f"Encryption plugin created: {plugin.name}")
    print(f"Enabled: {plugin.enabled}")
    
    # Test session lifecycle
    session_id = "test_session_123"
    plugin.on_recording_started(session_id)
    
    # Simulate some audio chunks
    import numpy as np
    
    for i in range(5):
        chunk = AudioChunk(
            data=np.random.random(1024).astype(np.float32),
            timestamp=time.time(),
            sample_rate=16000,
            speaker_id="speaker_001",
            consent_token="CT-test123",
            session_id=session_id,
            is_speech=True
        )
        
        plugin.process_audio(chunk)
        time.sleep(0.5)
    
    plugin.on_recording_stopped(session_id)
    plugin.cleanup()
    
    print("Encryption plugin test completed")
Displaying Encrypt.txt.
